---
title: "Циклы"
keywords:
  - for lop V
  - циклы V
description: Использование циклов в языке V
---

### Содержание:

- [Цикл for](#цикл-for)
- [Array for](#array-for)
- [Map for](#map-for)
- [Range (диапазон) for](#range-for)
- [Condition (условие) for](#condition-for)
- [Bare for](#bare-for)
- [C for](#c-for)
- [Labelled break & continue](#labelled-break--continue)



### Цикл For

В V есть только одно ключевое слово цикла: `for`, имеющее несколько форм.

#### `for`/`in`

Это наиболее распространенная форма. Ее можно использовать с массивом, картой или числовым диапазоном.

### Array `for`

```go
numbers := [1, 2, 3, 4, 5]
for num in numbers {
	println(num)
}
names := ['Sam', 'Peter']
for i, name in names {
	println('$i) $name')
	// Вывод:  0) Sam
	//         1) Peter
}
```

Форма `for value in arr` используется для перебора элементов массива. Если требуется индекс, можно использовать альтернативную форму `for index, value in arr`.

Обратите внимание, что значение доступно только для чтения. Если вам нужно изменить массив во время цикла, необходимо объявить элемент как изменяемый (`mut`):

```go
mut numbers := [0, 1, 2]
for mut num in numbers {
	num++
}
println(numbers) // [1, 2, 3]
```

Если идентификатор состоит из одного символа подчеркивания (` _`), он игнорируется.

### Map `for`

```go
m := map{
	'one': 1
	'two': 2
}
for key, value in m {
	println('$key -> $value')
	// Вывод:  one -> 1
	//         two -> 2
}
```

Ключ или значение можно игнорировать используя нижнее подчеркивание в качестве идентификатора. 

```go
m := map{
	'one': 1
	'two': 2
}
// итерация по ключам
for key, _ in m {
	println(key)
	// Вывод: one
	//        two
}
// итерация по значениям
for _, value in m {
	println(value)
	// Вывод: 1
	//        2
}
```

### Range `for`

```go
// Вывести '01234'
for i in 0 .. 5 {
	print(i)
}
```

`low..high` означает диапазон, который представляет все значения от `low` до `high`, но не включая high.

### Condition `for`

```go
mut sum := 0
mut i := 0
for i <= 100 {
	sum += i
	i++
}
println(sum) // "5050"
```

Эта форма цикла похожа на циклы `while` в других языках. Цикл прекратит итерацию, как только условие логического типа будет оценено как false. 

### Bare `for`

```go
mut num := 0
for {
	num += 2
	if num >= 10 {
		break
	}
}
println(num) // "10"
```

Условие может быть опущено, что приведет к бесконечному циклу.

### C `for`

```go
for i := 0; i < 10; i += 2 {
	// Не печатать 6
	if i == 6 {
		continue
	}
	println(i)
}
```

Наконец, существует традиционный цикл `for` в стиле языка Си. Он более безопасен, чем форма `while`, поскольку в последнем случае легко забыть обновить счетчик и застрять в бесконечном цикле.

Здесь `i` не нужно объявлять с `mut`, поскольку он всегда будет изменяемым по определению.

### Labelled break & continue

`break` и `continue` управляют самым внутренним циклом `for`. Вы также можете использовать `break` и `continue` с последующим именем метки (`outer`) для ссылки на внешний цикл `for`:

```go
outer: for i := 4; true; i++ {
	println(i)
	for {
		if i < 7 {
			continue outer
		} else {
			break outer
		}
	}
}
```

Метка должна непосредственно предшествовать внешнему (`outer`) циклу. Приведенный выше код печатает:

```go
4
5
6
7
```
